# 事件循环 event loop

## 1. 执行栈

1. 当一系列方法被依次调用的时候，因为`js`是单线程的，同一时间只能执行一个方法函数执行，于是这些方法被排队在一个单独的地方，这个地方就叫做执行栈。
2. 当我们调用一个方法的时候，`js`会生成一个与这个方法对应的执行上下文。这个执行环境中存在着这个方法的私有作用域，上层作用域的指向，方法的参数，这个作用域中定义的变量以及这个作用域的`this`对象。
3. 当一个脚本第一次执行的时候，`js`引擎会解析这段代码，并将其中的同步代码按照执行顺序加入执行栈中，然后从头开始执行。如果当前执行的是一个方法，那么 js 会向执行栈中添加这个方法的执行环境，然后进入这个执行环境继续执行其中的代码（类似于在函数中继续调用函数）这个过程又叫压栈，函数按执行顺序被压倒栈底。当执行完成后没有被其他的函数所引用，会进行弹栈，该函数会被弹出栈。该例子如下

```js
// 有这么一段代码
function fn1(){
  // 其他代码
  fn2()
}
function fn2(){
  // 其他代码
  fn3()
}
function fn3() {
  // 其他代码
}
fn1()
```

4. 当这个执行环境中的代码执行完毕并返回结果后，`js` 会退出这个执行环境并把这个执行环境销毁，回到上一个方法的执行环境（这个过程叫做弹栈）。

5. 一个方法执行会向执行栈中加入这个方法的执行环境，在这个执行环境中还可以调用其他方法，甚至是自己，其结果不过是在执行栈中再添加一个执行环境。这个过程可以是无限进行下去的，除非发生了栈溢出，即超过了所能使用内存的最大值。

## 2. 事件队列（Task Queue）

1.  `js`引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件（例如点击事件，ajax 请求，定时器事件）返回结果后，`js`会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。
2.  被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码，遇到异步任务就挂起...如此循环。

## 3. 异步任务区别

1. 异步任务之间并不相同，因此他们的执行优先级也有区别。异步任务被分为两类：微任务（micro task）和宏任务（macro task）。

### 宏任务（macro task）

1. `setInterval()`
2. `setTimeout()`

### 微任务（micro task）

1. `new Promise()`，后面的`.then`才是异步。
2. `new MutaionObserver()`

### 事件队列的处理方式

1. 在一个事件循环中，异步事件返回结果后会被放到一个任务队列中。根据这个异步事件的类型，这个事件实际上会被对应的宏任务队列或者微任务队列中去。在当前执行栈为空的时候，主线程会查看微任务队列是否有事件存在。

- 如果不存在，那么再去宏任务队列中取出一个事件并把对应的回到加入当前执行栈
- 如果存在，则会依次执行队列中事件对应的回调，直到微任务队列为空，然后去宏任务队列中取出最前面的一个事件，把对应的回调加入当前执行栈...如此反复，进入循环。
- 只需记住当当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。

```js
setTimeout(function () {
  console.log(1) // 宏任务
})

new Promise(function (resolve, reject) {
  console.log(2) // 同步任务
  resolve(3)
}).then(function (val) {
  console.log(val) // 微任务
})

// 结果 2 3 1
```
