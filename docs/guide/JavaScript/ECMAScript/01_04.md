# 数据类型

## 1. 简单数据类型与复杂数据类型

### 简单数据类型

1. 数值`number`: 整数和小数。
2. 字符串`string`: 文本
3. 布尔值`boolen`: `true` 和 `false`
4. `undefined`: 表示未定义或不存在，没有任何值
5. `null`: 表示空值，值为空

### 复杂数据类型

1. 对象`object`: 各种值组成的集合。
2. 数组`array`
3. 函数`function`

## 2.类型判断

1. 使用 `typeof` 运算符判断类型

```js
typeof 123 // "number"
typeof '123' // "string"
typeof false // "boolean"
typeof undefined // "undefined"
typeof {} // "object"
typeof v // "undefined"，使用 `typeof` 判断一个未声明的变量，不会报错。
typeof null // "object"
typeof [] // "object"
function f() {}
typeof f // "function"
```

2. `instanceof`运算符，能确定某个实例是否由某个构造函数创建。
3. `Object.prototype.toString`方法，能较准确的判断类型。

## 3. null，undefined，Boolean

1. `null` 表示空值，一个表示“空”的对象，即该处的值现在为空，转为数值时为 `0`。
2. `undefined` 表示未定义，转为数值时为`NaN`。

```js
undefined == null // true
```

2. 布尔值代表真和假两个状态。真用关键字`true`表示，假用关键字`false`表示，布尔值只有这两个值。

3. 下列运算符会返回布尔值:

- 前置逻辑运算符: `!` (取反)
- 相等运算符: `===` (全等)，`!==` (不全等)，`==` (相等)，`!=` (不相等)
- 比较运算符: `>` (大于)，`>=` (大于等于)，`<` (小于)，`<=` (小于等于)

3. 如果 `JavaScript` 预期某个位置应该是布尔值，会将该位置上现有的值隐式转换为布尔值。除了`undefined`，`null`，`NaN`，`0`，`false`，`''` 或 `""` (空字符串，不包含空格)这六个值被转为`false`，其他值都视为`true`。

## 4. 数值

### 数值中的整数和浮点数

1. `JavaScript` 内部，所有数字都是以 `64位(二进制)`浮点数形式储存，即使整数也是如此。这就是说，`JavaScript` 语言的底层根本没有整数，所有数字都是小数。某些运算只有整数才能完成，此时 `JavaScript` 会自动把 `64` 位浮点数，转成 `32` 位整数，然后再进行运算。

2. 根据国际标准 ` IEEE 754`，`JavaScript ` 浮点数的 `64` 个二进制位，从最左边开始，是这样组成的。

- 第 `1` 位: 符号位，`0` 表示正数，`1` 表示负数
- 第 `2` 位到第 `12` 位: 指数部分
- 第 `13` 位到第 `64` 位: 小数部分

3. 精度最多只能到 `53` 个二进制位，这意味着，`-2` 的 `53` 次方到 `2` 的 `53` 次方，都可以精确表示。由于 `2 `的 `53` 次方是一个 `16` 位的十进制数值，所以简单的法则就是，`JavaScript` 对 `15` 位的十进制数都可以精确处理。

```js
Math.pow(2, 53) // 9007199254740992
Math.pow(2, 53) + 1 // 9007199254740992
Math.pow(2, 53) + 3 // 9007199254740996
Math.pow(2, 53) + 4 // 9007199254740996

// 大于2的53次方以后，整数运算的结果开始出现错误。
```

4. 根据标准， `JavaScript` 能够表示的数值范围为 `2^1024` 到 `2^-1023`(开区间),超出这个范围的数无法表示。

- 如果一个数大于等于 `2 的 1024 次方`，那么就会发生正向溢出，即 `JavaScript` 无法表示这么大的数，这时就会返回 `Infinity。`
- 如果一个数小于等于 `2 的-1075 次方`，那么就会发生为负向溢出，即 `JavaScript` 无法表示这么小的数，这时会直接返回 `0`。
- `JavaScript` 提供`Number`对象的`MAX_VALUE`和`MIN_VALUE`属性，返回可以表示的具体的最大值和最小值。

```js
Math.pow(2, 1024) // Infinity
Math.pow(2, -1075) // 0
Number.MAX_VALUE // 1.7976931348623157e+308
Number.MIN_VALUE // 5e-324
```

### 数值的表示

1. `JavaScript` 的数值有多种表示方法，可以用字面形式直接表示:

- `0b010(二进制)`: 有前缀`0b`或`0B`的数值。
- `0o35(八进制)`: 有前缀`0o`或`0O`的数值，或者有前导`0`、且只用到`0-7`的八个阿拉伯数字的数值。
- `35(十进制)`: 没有前导`0`的数值。
- `0xFF(十六进制)`: 有前缀`0x`或`0X`的数值。

2. 默认情况下，`JavaScript` 内部会自动将八进制、十六进制、二进制转为十进制。如果八进制、十六进制、二进制的数值里面，出现不属于该进制的数字，就会报错。

```js
0xff // 255
0o377 // 255
0b11 // 3

0xzz // 报错
0o88 // 报错
0b22 // 报错

```

- 有前导 `0` 的数值会被视为八进制，但是如果前导 `0` 后面有数字 `8` 和 `9`，则该数值被视为十进制。前导 `0` 表示八进制，处理时很容易造成混乱。`ES5` 的严格模式和 `ES6`，已经废除了这种表示法。但是浏览器为了兼容以前的代码，目前还继续支持这种表示法。

```js
0888 // 888
0777 // 511
```

3. 数值也可以采用科学计数法表示，科学计数法允许字母 `e `或 `E` 的后面，跟着一个整数，表示这个数值的指数部分。小数点前的数字多于 `21` 位，或者小数点后的零多于 `5` 个时 `JavaScript` 会自动将数值转为科学计数法表示。

```js
123e3 // 123000
123e-3 // 0.123

1234567890123456789012 // 1.2345678901234568e+21
0.0000003 // 3e-7
```

### 特殊的数值

1. 正零和负零，`JavaScript` 内部实际上存在 `2 `个` 0`: 一个是`+0`，一个是`-0`。区别就是 `64` 位浮点数表示法的符号位不同，它们是等价的。唯一有区别的场合是，`+0` 或`-0` 当作分母，返回的值是不相等的。除以正零得到`+Infinity`，除以负零得到`-Infinity`。

2. `NaN` 是 `JavaScript` 的特殊值，`Not a Number`，主要出现在将字符串解析成数字出错的场合。`0` 除以` 0` 也会得到 `NaN`。`NaN` 不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于 `Number`。

- `NaN` 不等于任何值，包括它本身。
- 数组的 `indexOf` 方法内部使用的是严格相等运算符，所以该方法对 `NaN` 不成立。
- `NaN` 在布尔运算时被当作 `false。`
- `NaN` 与任何数的运算，得到的都是 `NaN`。

3. `Infinity`表示“无穷”，用来表示两种场景。一种是一个正的数值太大，或一个负的数值太小，无法表示，`Infinity`表示正的无穷，`-Infinity`表示负的无穷。

- `Infinity` 的四则运算，符合无穷的数学计算规则。
- `0` 乘以 `Infinity`，返回 `NaN`；`0` 除以 `Infinity`，返回 `0`；`Infinity` 除以 `0`，返回 `Infinity`。
- `Infinity` 加上或乘以 `Infinity`，返回的还是 `Infinity`。
- `Infinity` 减去或除以 `Infinity`，得到 `NaN`。
- `Infinity` 与 `null` 计算时，`null` 会转成 `0`，等同于与 `0` 的计算。
- `Infinity` 与 `undefined` 计算，返回的都是 `NaN`。

## 5. 字符串

### 字符串的定义

1. 字符串就是零个或多个排在一起的字符，放在单引号或双引号之中`'abc'`,`"abc"`。

2. 单引号字符串的内部，可以使用双引号。双引号字符串的内部，可以使用单引号`'key = "value"'`, `"It's a long journey"`。
3. 如果要在单引号字符串的内部，使用单引号，就必须在内部的单引号前面加上反斜杠，用来转义。
   双引号字符串内部使用双引号，也是如此。
4. 字符串默认只能写在一行内，分成多行将会报错。如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。
5. 连接运算符(+)可以连接多个单行字符串，将长字符串拆成多行书写，输出的时候也是单行。

```js
var str = 'a' + 'b' + 'c'
str // 'abc'
```

### 转义符

1. 在字符串内有特殊含义，用来表示一些特殊字符，需要用反斜杠转义的特殊字符，主要有下面这些。

- `\0` : null (\u0000)
- `\b` : 后退键 (\u0008)
- `\f` : 换页符 (\u000C)
- `\n` : 换行符 (\u000A)
- `\r` : 回车键 (\u000D)
- `\t` : 制表符 (\u0009)
- `\v` : 垂直制表符 (\u000B)
- `\'` : 单引号 (\u0027)
- `\"` : 双引号 (\u0022)
- `\\` : 反斜杠 (\u005C)

### 字符串与数组

1. 字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符。

```js
var s = 'hello'
s[0] // "h"
```

2. 如果方括号中的数字超过字符串的长度，或者方括号中根本不是数字，则返回`undefined`。

```js
s[-1] // undefined
s['x'] // undefined
```

3. 字符串无法改变字符串之中的单个字符

```js
delete s[0]
s // "hello"

s[1] = 'a'
s // "hello"
```

4. 与数组一样也有`length`属性，返回字符串的长度，但是字符串的该属性也是无法改变的。

```js
var s = 'hello'
s.length = 3
s.length // 5
```

### 字符集

1. `JavaScript` 使用 `Unicode` 字符集。`JavaScript` 引擎内部，所有字符都用 `Unicode` 表示。还允许直接在程序中使用 `Unicode` 码点表示字符，即将字符写成`\uxxxx`的形式，其中`xxxx`代表该字符的 `Unicode` 码点。

```js
var s = '\u00A9'
s // "©"

var foo = 'abc'
foo // "abc"，第一行变量名变量名是用 Unicode 形式表示的
```

2. `JavaScript` 内部都是以 `2` 个字节的 `UTF-16` 格式储存。但是，`UTF-16` 有两种长度: 对于码点在`U+0000`到`U+FFFF`之间的字符，长度即 `2` 个字节；对于码点在`U+10000`到`U+10FFFF`之间的字符，即 `4` 个字节。`JavaScript` 对 `UTF-16` 的支持是不完整的。当遇到四个字节的字符 `Javascript`会以为有两个字符。

```js
'𝌆'.length // 2, JavaScript 认为𝌆的长度为2，而不是1。
```

### Base64

1. 所谓 `Base64` 就是一种编码方法，可以将任意值转成 `0 ～ 9、A ～ Z、a-z、+和/`这 `64` 个字符组成的可打印字符。使用它的主要目的，是为了不出现特殊字符，简化程序的处理。

2. `JavaScript` 原生提供两个 `Base64` 相关的方法。注意，这两个方法不适合非 `ASCII` 码的字符，会报错。

- `btoa()`: 任意值转为 `Base64` 编码
- `atob()`: `Base64` 编码转为原来的值

```js
var string = 'Hello World!'
btoa(string) // "SGVsbG8gV29ybGQh"
atob('SGVsbG8gV29ybGQh') // "Hello World!"
btoa('你好') // 报错

// 将非 ASCII 码的字符转为 Base64
function b64Encode(str) {
  return btoa(encodeURIComponent(str))
}

// 将非 ASCII 码的字符转为的 Base64 码转回去
function b64Decode(str) {
  return decodeURIComponent(atob(str))
}
```

## 6. 数组

### 含义

1. 数组是按次序排列的一组值。每个值的位置都有自己的索引从 `0` 开始，整个数组用方括号表示。

- 除了在定义时赋值，数组也可以先定义后赋值。
- 任何类型的数据，都可以放入数组。
- 如果数组的元素还是数组，就形成了多维数组。

```js
var arr = ['a', 'b', 'c']

var arr1 = []
arr[0] = 'a'
arr[1] = 'b'
arr[2] = 'c'

var arr2 = [
  { a: 1 },
  [1, 2, 3],
  function () {
    return true
  }
]

var arr3 = [
  [1, 2],
  [3, 4]
]
```

2. 数组的本质

- 数组属于一种特殊的对象
- 它的键名是它的索引值
- 数组可以用方括号包裹数值读取，是因为非字符串的键名会被转为字符串。
- 数组赋值时，方括号里的值总是先转成字符串，再作为键名进行赋值。

```js
var arr = ['a', 'b', 'c']

typeof arr // "object"

Object.keys(arr) // ["0", "1", "2"]

arr['0'] // 'a'
arr[0] // 'a'

arr[1.0] = 6
arr[1] // 6
```

### length 属性

1. 数组的 `length` 属性，返回数组的成员数量。`length` 属性的最大值就是 `4294967295`。

```js
var arr = ['a', 'b', 'c']
arr.length // 3
```

2. `length` 属性是可写的，设置一个小于当前成员个数的值，该数组的成员数量会自动减少到 `length` 设置的值。设置 `length` 大于当前元素个数，则数组的成员数量会增加到这个值，新增的位置都是空位`(empty)`，读取空位中的值时返回 `undefined`。

```js
var arr = ['a', 'b', 'c']
arr.length // 3

arr.length = 2
arr // ["a", "b"]

arr.length = 5
arr // ["a", "b", empty * 3]
arr[2] // undefined
```

3. 如果人为设置`length`为不合法的值，`JavaScript` 会报错。

```js
arr.length = -1 // RangeError: Invalid array length
```

4. 由于数组本质上是一种对象，所以可以为数组添加属性，但是这不影响`length`属性的值。

```js
var arr = ['a', 'b', 'c']
arr.length // 3

arr['d'] = 'd'
arr.length // 3
```

5. 如果数组的键名是添加超出范围的数值，该键名会自动转为字符串，类似于添加属性。

```js
arr[-3] = 'e'
arr['-3'] // e
arr.length // 3
```

### in 运算符

1. 检查某个键名是否存在的运算符`in`，适用于对象，也适用于数组。

```js
var arr = ['a', 'b', 'c']
2 in arr // true
3 in arr // false
```

2. 由于键名都是字符串，所以数值会自动转成字符串。

```js
var arr = ['a', 'b', 'c']
2 in arr // true
'2' in arr // true
```

3. 如果数组的某个位置是空位`(empty`)，`in` 运算符返回 `false`。

```js
var arr = ['a', 'b', 'c']
arr.length = 5
4 in arr // false
```

### for...in 循环和数组的遍历

1. `for...in`循环不仅可以遍历对象，也可以遍历数组，它不仅会遍历数组所有的数字键，还会遍历非数字键。

```js
var a = [1, 2, 3]

a.foo = true
for (var key in a) {
  console.log(key)
}
// 0
// 1
// 2
// foo
```

### 数组的空位

1. 当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位。
2. 数组的空位不影响 `length` 属性，虽然这个位置没有值，引擎依然认为这个位置是有效的。

```js
var a = [1, , 1]
a.length // 4
```

3. 数组的空位是可以读取的，返回`undefined`。

```js
var a = [1, , 1]
a[1] // undefined
```

4. 使用`delete`命令删除一个数组成员，会形成空位，并且不会影响`length`属性。

```js
var a = [1, , 1]
delete a[2] // true
a // [1, empty × 2]
```

5. 数组的某个位置是空位，与某个位置是`undefined`，是不一样的，虽然读取时都是`undefined`。使用数组的`forEach`方法、`for...in`结构、以及`Object.keys`方法进行遍历，空位都会被跳过。如果某个位置是`undefined`，遍历的时候就不会被跳过。

```js
a.forEach(function (item, index) {
  console.log(index + '-' + item)
})
// 0 - 1
// 2 - 1
// 3 - undefined
```

### 类似数组的对象

1. 如果一个对象的所有键名都是正整数或零，并且有`length`属性，那么这个对象就很像数组，语法上称为‘类数组’或‘伪数组’。

2. “类似数组的对象”并不是数组，因为它们不具备数组特有的方法。“类似数组的对象”的根本特征，就是具有`length`属性。只要有`length`属性，就可以认为这个对象类似于数组。但是有一个问题，这种`length`属性不是动态值，不会随着成员的变化而变化。
3. 典型的“类似数组的对象”是函数的`arguments`对象，以及大多数 `DOM` 元素集，还有字符串。
4. 数组的`slice`方法可以将“类似数组的对象”变成真正的数组。

```js
var obj = {
  0: 'a',
  1: 'b',
  2: 'c',
  length: 3
} // 类数组

var arr = Array.prototype.slice.call(arrayLike) // 变成真正的数组
```

5. “类似数组的对象”可以通过`call()`把数组的方法放到对象上面，从而使用数组的方法。

```js
function logArgs() {
  Array.prototype.forEach.call(arguments, function (elem, i) {
    console.log(i + '. ' + elem)
  })
}
```

## 7. 对象

### 含义

1. 对象`object`是 `JavaScript` 语言的核心概念，也是最重要的数据类型。简单说，对象就是一组组键值对`(key-value)`的集合。

```js
// 大括号就定义了一个对象，它被赋值给变量 obj,变量 obj 就指向一个的内存地址。
var obj = {}
```

2. 对象的所有键名都是字符串，所以加不加引号都可以。

```js
// 第一个键值对是 foo: 'Hello'，其中 foo 是“键名”，字符串Hello是“键值”。
var obj = {
  foo: 'Hello',
  bar: 'World'
}
```

3. 如果键名是数值，会被自动转为字符串。且引用的时候得用中括号运算符，否则会报错。

```js
var obj = {
  1: 11, // obj['1'] -> 11, obj[1] -> 11
  2: 22 // obj[2] -> 22, obj['2'] -> 22
}
```

4. 如果键名不符合标识名的条件，且也不是数字，则必须加上引号，否则会报错。

```js
var obj = {
  'p+q': 'Hello World'
}
```

5. 对象的每一个键名又称为“属性”，如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用。

```js
var obj = {
  p: function (x) {
    return 2 * x
  }
}
obj.p(2) // 4
```

6. 如果属性的值还是一个对象，就形成了链式引用。

```js
var obj = {
  o: {
    test: 'test'
  }
}
obj.o.test // 'test'
```

7. 属性可以动态创建，不必在对象声明时就指定。

```js
var obj = {}

obj.a = 'a'
obj.a // 'a'

obj['b'] = 'b'
obj.b // "b"
```

### 对象的引用

1. 如果不同的变量名指向同一个对象，也就是说指向同一个内存地址，修改其中一个变量，会影响到其他所有变量。

```js
var o1 = {}
var o2 = o1

o1.a = 1
o2.a // 1
o2.b = 2
o1.b // 2
```

2. 如果取消某一个变量对于原对象的引用，不会影响到另一个变量。

```js
var o1 = {}
var o2 = o1

o1 = 1
o2 // {a:1, b:2}
```

3. `JavaScript` 引擎无法确定是对象还是代码块时，一律解释为代码块。如果要解释为对象，最好在大括号前加上圆括号。因为圆括号的里面，只能是表达式，所以确保大括号只能解释为对象。

```js
{ console.log(123) } // 打印123
({ foo: 123 }) // 正确
({ console.log(123) }) // 报错
```

### 属性操作

1. 读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。

```js
var obj = {
  foo: 1,
  bar: 2
}

obj.foo // 1
obj['foo'] // 1
```

2. 如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。

```js
var foo = 'bar'
var obj = {
  foo: 1,
  bar: 2
}

obj['foo'] // 1
obj[foo] // 2
```

3. 方括号运算符内部还可以使用表达式。

```js
var obj = {
  foo: 1,
  bar: 2
}
obj['b' + 'ar'] // 2，相当于 obj['bar']
```

4. 数字键在方括号里可以不加引号，因为会自动转成字符串。但是数值键名不能使用点运算符。

```js
var obj = {
  12: 'hello',
  '13': 'world'
}

obj.12 // 报错
obj.'13' // 报错
obj[12] // 'hello' 相当于 obj['12']
```

- 点运算符和方括号运算符，不仅可以用来读取值，还可以用来赋值，点运算符后面只能是标识符。

```js
var obj = {}

obj.foo = 'Hello'
obj['bar'] = 'World'
```

### 其他操作

1. 查看一个对象本身的所有属性，可以使用`Object.keys`方法。

```js
var obj = {
  key1: 1,
  key2: 2,
  key3: 3
}

Object.keys(obj) // ['key1', 'key2', 'key3']
```

2. `delete`命令用于删除对象的属性，删除成功后返回`true`。 删除一个不存在的属性，`delete` 不报错，而且返回 `true`。只有一种情况，`delete` 命令会返回 `false`，那就是该属性存在，且不得删除。

```js
var obj = {
  key1: 1,
  key2: 2,
  key3: 3
}

delete obj.key1 // true
obj.key1 // undefined
```

3. `in`运算符用于检查对象是否包含某个属性，如果包含就返回 `true`，否则返回 `false`。它可以检查原型对象上是否有该属性。

```js
var obj = {
  key1: 1,
  key2: 2,
  key3: 3
}

'key2' in obj // true
'toString' in obj // true
```

4. `for...in`循环用来遍历一个对象的全部属性。它遍历的是对象所有可遍历的属性，会跳过不可遍历的属性。它还遍历继承的属性。

```js
var obj = {
  key1: 1,
  key2: 2,
  key3: 3
}

for (var key in obj) {
  console.log('键名：', key, '键值：', obj[key])
}
```
