# 函数类型

## 1. 函数类型表达式

1. 描述函数的最简单方法是使用函数类型表达式，类型在语法上类似于箭头函数。

```typescript
function greeter(fn: (a: string) => void) {
  // (a: string) => void 表示 一个带有一个参数、名为 a、类型为 string、没有返回值的函数
  fn('Hello, World')
}

function printToConsole(s: string) {
  console.log(s)
}

greeter(printToConsole)
```

## 2. 调用签名

1. 在`JavaScript`函数可以具有属性，`TypeScript`函数类型表达式语法不允许声明属性。这时候可以编写调用签名。
2. 在`TypeScript`中，接口和类型别名都可以支持多个调用签名，这通常用于模拟函数重载的行为。

```typescript
// 使用类型别名定义调用签名  
type fn = (someArg: number) => boolean
// 这种声明可以表示函数类型，并带有属性的调用签名
type Tfn = {
  description: string,
  (someArg: number): boolean
}

// 使用接口定义调用签名（接口中的方法也是调用签名的一种形式）  
interface Ifn {
  (a: number, b: number): number;
}


interface Calculator {
  (x: number, y: number): number; // 第一个调用签名  
  (x: number, y: number, z: number): number; // 第二个调用签名  
}

const add: Calculator = (x, y, z?) => {
  if(z) {
    return x + y + z
  } else {
    return x + y
  }
}

console.log(add(1, 2)) // 输出: 3  
console.log(add(1, 2, 3)) // 输出: 6
```

## 3. 构造签名

1. 构造签名是定义类构造函数类型的一种方式。
2. 以通过在调用签名前添加`new`关键字来编写构造签名。
3. 构造签名是类类型的一部分。

```typescript
// 定义一个动物接口，作为所有动物类的基类型
interface IAnimal {
  speak(): void
}

// 实现两个具体的动物类，Dog 和 Cat，它们都实现了 IAnimal 接口
class Dog implements IAnimal {
  name: string

  constructor(name: string) {
    this.name = name
  }

  speak() {
    console.log('Woof!')
  }
}

class Cat implements IAnimal {
  name: string

  constructor(name: string) {
    this.name = name
  }

  speak() {
    console.log('Meow!')
  }
}

// 定义一个接口，该接口包含一个构造签名，用于描述如何创建IAnimal类型的实例
interface IAnimalConstructor {
  new(name: string): IAnimal
}

// 实现一个工厂函数，该函数接受一个IAnimalConstructor类型的参数，并使用它来创建IAnimal类型的实例。
function createAnimal(animalConstructor: IAnimalConstructor, name: string): IAnimal {
  return new animalConstructor(name)
}

const dog: IAnimal = createAnimal(Dog, 'Buddy')
dog.speak() // 输出: Woof!  

const cat: IAnimal = createAnimal(Cat, 'Whiskers')
cat.speak() // 输出: Meow!
```

## 4. 泛型函数

1. 通常会编写一个函数，其中输入的类型与输出的类型相关，或者两个输入的类型以某种方式相关。

```typescript
function firstElement(arr: any[]) {
  return arr[0];
}

function secondElement<T>(arr: T[]): T {
  return arr[0]
}

const res1 = secondElement([1, 2, 3]) // res1 的类型被自动推断为 number
const res2 = secondElement<string>(['a', 'b', 'c']) // res2 的类型被设置为 string
```

### 1. 约束条件

1. 有时函数想对两个值的属性操作，此时可以使用约束来限制类型参数可以接受的类型种类。

```typescript
function longest<Type extends { length: number }>(a: Type, b: Type) {
  if(a.length >= b.length) {
    return a
  } else {
    return b
  }
}

const longerString = longest("alice", "bob") // longerString 的类型是 'alice' | 'bob'
const notOK = longest(10, 100) // 报错，因为数值没有 length 属性
// 或者限制传入的值的类型
const numberOrString = longest<string>(10, 100) // 这样如果传入的不是字符串，就会报错
```

### 2. 约束值

1. 可以使用函数泛型的形式来学术返回值

```typescript
function minimumLength<Type extends { length: number }>(obj: Type, minimum: number): Type {
  if(obj.length >= minimum) {
    return obj
  } else {
    return {length: minimum} // 错误，因为返回值类型与函数声明的返回值类型不匹配
  }
}
```

### 3. 指定类型参数

1. `TypeScript`通常可以在泛型调用中推断出预期的类型参数，但并非总是如此。这时就可以你可以手动指定`Type`。

```typescript
function combine<Type>(arr1: Type[], arr2: Type[]): Type[] {
  return arr1.concat(arr2)
}

const arr = combine([1, 2, 3], ['hello']) // 这时候推断起了冲突会报错
const arr2 = combine<number | string>([1, 2, 3], ['hello']) // 可以指定类型就不会有问题
```

## 5. 可选参数

1. 可选参数是使用`?`来表示的，可选参数必须放在必选参数后面。

```typescript
function f(x: number, y?: number) {
  //...
}

f(10, 10) // OK
f(10) // OK
f(undefined) // OK，undefined 可以传递给任何类型
```

## 6. 函数重载