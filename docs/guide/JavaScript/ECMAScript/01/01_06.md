# 标准库

## 1. Object 对象

### (1) 概述

1. `JavaScript` 原生提供 `Object` 对象，`JavaScript` 的所有其他对象都继承自 `Object` 对象，即那些对象都是 `Object` 的实例。
2. `Object` 对象的原生方法分成两类：`Object` 本身的方法（静态方法）与 `Object` 的实例方法。

- `Object` 对象本身的方法就是直接定义在 `Object` 对象的方法。

```js
Object.print = function () {}
```

- `Object` 的实例方法就是定义在 `Object` 原型对象 `Object.prototype` 上的方法。它可以被 `Object` 实例直接使用。

```js
Object.prototype.print = function () {
  return 'print'
}
var obj = new Object()
obj.print() // print
```

### (2) Object() 函数

1. `Object` 本身是一个函数，可以当作工具方法使用，将任意值转为对象。这个方法常用于保证某个值一定是对象。
2. 如果参数为空或者为 `undefined` 和 `null`，`Object()`返回一个空对象。

```js
var obj = Object()
// 等同于
var obj = Object(undefined)
var obj = Object(null)

obj instanceof Object // true
```

3. 如果参数是原始类型的值，`Object` 方法将其转为对应的包装对象的实例。

```js
var obj = Object(1)
obj instanceof Object // true
obj instanceof Number // true

var obj = Object('foo')
obj instanceof Object // true
obj instanceof String // true

var obj = Object(true)
obj instanceof Object // true
obj instanceof Boolean // true
```

4. 如果 `Object` 方法的参数是一个对象，它总是返回该对象，即不用转换。

```js
var arr = []
var obj = Object(arr) // 返回原数组
obj === arr // true

var value = {}
var obj = Object(value) // 返回原对象
obj === value // true

var fn = function () {}
var obj = Object(fn) // 返回原函数
obj === fn // true
```

5. 利用这一点，可以写一个判断变量是否为复杂数据类型的函数。

```js
function isObject(value) {
  return value === Object(value)
}

isObject([]) // true
isObject(true) // false
```

### (3) Object 构造函数

1. `Object` 还可以当作构造函数使用，构造函数的首要用途，是直接通过它来生成新对象。

```js
var obj = new Object()
// 与字面量的写法 var obj = {} 是等价的
```

2. `Object` 构造函数的用法与工具方法很相似，可以接受一个参数。

- 如果该参数是一个对象，则直接返回这个对象。
- 如果该参数是一个原始类型的值，则返回该值对应的包装对象。

```js
var o1 = { a: 1 }
var o2 = new Object(o1)
o1 === o2 // true

var obj = new Object(123)
obj instanceof Number // true
```

3. `Object(value)` 与 `new Object(value)` 两者的语义是不同的，前者表示将`value`转成一个对象，
   后者则表示新生成一个对象，它的值是 `value`。

### (4) Object 静态方法（自身方法）

1. `Object.keys`

- 方法的参数是一个对象，返回一个数组。该数组的成员都是该对象自身的而不是继承的所有属性名。
- 方法只返回可枚举的属性。

```js
var obj = {
  p1: 123,
  p2: 456
}

Object.keys(obj) // ["p1", "p2"]
```

2. `Object.getOwnPropertyNames`

- 方法是接受一个对象作为参数，返回一个数组，包含了该对象自身的所有属性名。
- 方法还可以返回不可枚举的属性名。数组的 `length` 属性是不可枚举的属性。

```js
var a = ['Hello', 'World']
Object.getOwnPropertyNames(a) // ["0", "1", "length"]
```

3. 其他静态方法

- 对象属性模型的相关方法
  - `Object.getOwnPropertyDescriptor()`：获取某个属性的描述对象。
  - `Object.defineProperty()`：通过描述对象，定义某个属性。
  - `Object.defineProperties()`：通过描述对象，定义多个属性。
- 控制对象状态的方法
  - `Object.preventExtensions()`：防止对象扩展。
  - `Object.isExtensible()`：判断对象是否可扩展。
  - `Object.seal()`：禁止对象配置。
  - `Object.isSealed()`：判断一个对象是否可配置。
  - `Object.freeze()`：冻结一个对象。
  - `Object.isFrozen()`：判断一个对象是否被冻结。
- 原型链相关方法
  - `Object.create()`：该方法可以指定原型对象和属性，返回一个新的对象。
  - `Object.getPrototypeOf()`：获取对象的 `Prototype` 对象。

### (5) Object 实例方法（ 在 Object.prototype 上的方法）

1. `Object.prototype.valueOf()`

- 返回当前对象对应的值，默认情况下返回对象本身。

```js
var obj = new Object()
obj.valueOf() === obj // true
```

- `JavaScript` 自动类型转换时会默认调用 `valueOf()` 方法。

```js
// 自定义的 obj.valueOf，覆盖 Object.prototype.valueOf
var obj = new Object()
obj.valueOf = function () {
  return 2
}

1 + obj // 3
```

2. `Object.prototype.toString()`

- 返回一个对象的字符串形式，默认情况下返回类型字符串。可以看出一个值到底是什么类型。

```js
var o2 = { a: 1 }
o2.toString() // "[object Object]"
Object.prototype.toString.call(2) // "[object Number]"
```

- 对象在自动类型转换时会调用 `toString()` 方法。

```js
var obj = new Object()

obj.toString = function () {
  return 'hello'
}

obj + ' world' // "hello world"
```

3. `Object.prototype.toLocaleString()`

- 方法与 `toString` 的返回结果相同，也是返回一个值的字符串形式。
- 方法主要作用是留出一个接口，让不同的对象实现自己版本的 `toLocaleString`，用来返回针对某些地域的特定的值。

```js
var person = {
  toString: function () {
    return 'toString'
  },
  toLocaleString: function () {
    return 'toLocaleString'
  }
}

person.toString() // toString
person.toLocaleString() // toLocaleString
```

- 主要有三个对象自定义了 `toLocaleString` 方法。
  - `Array.prototype.toLocaleString()`
  - `Number.prototype.toLocaleString()`
  - `Date.prototype.toLocaleString()`

```js
var date = new Date()
date.toString() // "Tue Jan 01 2018 12:01:33 GMT+0800 (CST)"
date.toLocaleString() // "1/01/2018, 12:01:33 PM"
```

4. `Object.prototype.hasOwnProperty()`，方法接受一个字符串作为参数，返回一个布尔值，表示该实例对象自身是否具有该属性。
   继承的属性不能找到。

```js
var obj = {
  p: 123
}

obj.hasOwnProperty('p') // true
obj.hasOwnProperty('toString') // false
```

## 2. 对象的属性描述对象

### (1) 概述

1. `JavaScript` 提供了一个内部数据结构，用来描述对象的属性，控制它的行为。这个内部数据结构称为“属性描述对象。
2. 每个属性都有自己对应的属性描述对象，保存该属性的一些元信息。属性描述对象提供 6 个元属性。

```js
{
  value: 'JavaScript',
  // value是该属性的属性值，默认为undefined。
  writable: false,
  // writable是一个布尔值，表示属性值（value）是否可改变（即是否可写），默认为true。
  enumerable: true,
  // enumerable是一个布尔值，表示该属性是否可遍历，默认为true。
  configurable: false,
  // configurable是一个布尔值，表示属性的可配置性，默认为true。
  // 如果设为false，将无法删除该属性，也不得改变除 value 属性外的元属性。
  get: undefined,
  // get是一个函数，表示该属性的取值函数，默认为undefined。
  set: undefined
  // set是一个函数，表示该属性的存值函数，默认为undefined。
}
```

### (2) Object.getOwnPropertyDescriptor()

1. 方法可以获取属性描述对象。它的第一个参数是目标对象，第二个参数是一个字符串，对应目标对象的某个属性名。

```js
var obj = { p: 'a' }

Object.getOwnPropertyDescriptor(obj, 'p')
// {
//   value: "a",
//   writable: true,
//   enumerable: true,
//   configurable: true
// }
```

2. 方法只能用于对象自身的属性，不能用于继承的属性。

```js
var obj = { p: 'a' }

Object.getOwnPropertyDescriptor(obj, 'toString')
// undefined
```

### (3) Object.defineProperty()

1. 方法允许通过属性描述对象，定义或修改一个属性，然后返回修改后的对象。
2. 方法接受三个参数：

- 属性所在的对象
- 字符串，表示属性名
- 属性描述对象

```js
var obj1 = { p: 111 }
var obj2 = Object.defineProperty({}, 'p', {
  value: 123,
  writable: false,
  enumerable: true,
  configurable: false
})
obj1.p // 123
obj1 === obj2 // true
```

3. 如果写入的对象或对象的属性已经存在，方法相当于更新该属性的属性描述对象。
4. 定义了取值函数`get`或存值函数`set`，就不能将`writable`属性设为`true`，或者同时定义`value`属性，否则会报错。

### (4) Object.defineProperties()

1. 方法功能与上个一样，但是能一次性定义或修改多个属性。

```js
var obj = Object.defineProperties(
  {},
  {
    p1: { value: 123, enumerable: true },
    p2: { value: 'abc', enumerable: true },
    p3: {
      get: function () {
        return this.p1 + this.p2
      },
      enumerable: true,
      configurable: true
    }
  }
)
```

2. 定义了取值函数`get`或存值函数`set`，就不能将`writable`属性设为`true`，或者同时定义`value`属性，否则会报错。

### (5) Object.prototype.propertyIsEnumerable()

1. 方法返回一个布尔值，用来判断某个属性是否可遍历。
2. 方法只能用于判断对象自身的属性，对于继承的属性一律返回`false`。

```js
var obj = {}
obj.p = 123

obj.propertyIsEnumerable('p') // true
obj.propertyIsEnumerable('toString') // false
```

### (6) 存取器

1. 属性还可以用存取器定义，一旦对目标属性定义了存取器，那么存取的时候，都将执行对应的函数。
2. 存值函数称为`setter`，使用属性描述对象的`set`属性。取值函数称为`getter`，使用属性描述对象的`get`属性。

- 第一种写法，`obj.p`定义了`get`和`set`属性。
  - `obj.p`取值时，就会调用`get`；赋值时，就会调用`set`。
  - 这种写法，属性`p`的`configurable`和`enumerable`都为`false`，从而导致属性`p`是不可遍历的。

```js
var obj = {}
Object.defineProperty(obj, 'p', {
  get: function () {
    return 'getter'
  },
  set: function (value) {
    console.log('setter: ' + value)
  }
})
obj.p // "getter"
obj.p = 123 // "setter: 123"
```

- 第二种写法，属性`p`的读取和赋值行为与第一种一样。
  - `obj.p`取值时，就会调用`get`；赋值时，就会调用`set`。
  - 这种写法属性`p`的`configurable`和`enumerable`都为`true`，因此属性`p`是可遍历的。

```js
var obj = {
  get p() {
    return 'getter'
  },
  set p(value) {
    console.log('setter: ' + value)
  }
}
```

3. 取值函数`get`不能接受参数，存值函数`set`只能接受一个参数（即属性的值）。

### (7) 控制对象状态

1. 有时需要冻结对象的读写状态，防止对象被改变，`JavaScript` 提供了三种冻结方法。

- 最弱的一种是 `Object.preventExtensions`。
- 其次是 `Object.seal`。
- 最强的是 `Object.freeze`。

2. 控制添加新属性

- `Object.preventExtensions`，方法可以使得一个对象无法再添加新的属性。

```js
var obj = {}

obj.p = 1
obj.p // undefined

Object.defineProperty(obj, 'p', {
  value: 'hello'
})
// TypeError: Cannot define property:p, object is not extensible.
```

- `Object.isExtensible`，方法用于检查一个对象是否使用了`Object.preventExtensions`方法。
  也就是检查是否可以为一个对象添加属性。

```js
var obj = {}

Object.isExtensible(obj) // true
Object.preventExtensions(obj)
Object.isExtensible(obj) // false
```

3. 控制添加新属性和删除属性

- `Object.seal`，方法使得一个对象既无法添加新属性，也无法删除旧属性。

```js
var obj = { p: 'hello' }
Object.seal(obj)

delete obj.p
obj.p // "hello"

obj.x = 'world'
obj.x // undefined
```

- `Object.seal`实质是把属性描述对象的`configurable`属性设为`false`，因此属性描述对象也不再能改变了。

```js
var obj = {
  p: 'a'
}

// seal方法之前
Object.getOwnPropertyDescriptor(obj, 'p')
{
  value: "a",
  writable: true,
  enumerable: true,
  configurable: true
}

// seal方法之后
Object.getOwnPropertyDescriptor(obj, 'p')
{
  value: "a",
  writable: true,
  enumerable: true,
  configurable: false
}

// 使用Object.seal方法之后，属性描述对象的configurable属性就变成了false，
// 然后改变enumerable属性就会报错。
Object.defineProperty(obj, 'p', {
  enumerable: false
})
// TypeError: Cannot redefine property: p
```

- `Object.seal` 只是禁止新增或删除属性，并不影响修改某个属性的值。`Object.seal`方法对`p`属性的`value`无效，是因为此时`p`属性的可写性由`writable`决定。
- `Object.isSealed`，方法用于检查一个对象是否使用了`Object.seal`方法。

```js
var obj = {}

Object.seal(obj)
Object.isSealed(obj) // true
```

4. 控制添加新属性、删除属性、改变属性值。

- `Object.freeze`方法可以使得一个对象无法添加新属性、无法删除旧属性、也无法改变属性的值，使得这个对象实际上变成了常量。

```js
var obj = {
  p: 'hello'
}

Object.freeze(obj)

obj.p = 'world'
obj.p // "hello"

obj.t = 'hello'
obj.t // undefined

delete obj.p // false
obj.p // "hello"
```

- `Object.isFrozen`，方法用于检查一个对象是否使用了`Object.freeze`方法。`Object.isSealed`也将会返回 `true`。

```js
var obj = {
  p: 'hello'
}

Object.freeze(obj)
Object.isFrozen(obj) // true
Object.isSealed(obj) // true
```

- 上面的三个方法锁定对象的可写性有一个漏洞：可以通过改变原型对象，来为对象增加属性。

## 3. Array 对象

### (1) 构造函数

1. `Array` 是 `JavaScript` 的原生对象，同时也是一个构造函数，可以用它生成新的数组。

- 如果没有使用 `new` 关键字，运行结果也是一样的。

```js
var arr = new Array(2)
// 等同于
var arr = Array(2)

arr.length // 2
arr // [ empty x 2 ]
```

- `Array()`构造函数有一个很大的缺陷，不同的参数个数会导致不一致的行为。不建议使用它生成新数组，直接使用数组字面量是更好的做法。

```js
// 无参数时，返回一个空数组
new Array() // []

// 单个正整数参数，表示返回的新数组的长度
new Array(1) // [ empty ]
new Array(2) // [ empty x 2 ]

// 非正整数的数值作为参数，会报错
new Array(3.2) // RangeError: Invalid array length
new Array(-3) // RangeError: Invalid array length

// 单个非数值（比如字符串、布尔值、对象等）作为参数，
// 则该参数是返回的新数组的成员
new Array('abc') // ['abc']
new Array([1]) // [Array[1]]

// 多参数时，所有参数都是返回的新数组的成员
new Array(1, 2) // [1, 2]
new Array('a', 'b', 'c') // ['a', 'b', 'c']
```

- 如果参数是一个正整数，返回数组的成员都是空位。虽然读取的时候返回 `undefined`，但实际上该位置没有任何值。虽然这时可以读取到 `length` 属性，但是取不到键名。

```js
var a = new Array(3)
var b = [undefined, undefined, undefined]

a.length // 3
b.length // 3

a[0] // undefined
b[0] // undefined

0 in a // false
0 in b // true
```

### (2) 静态方法

1. `Array.isArray()`，方法返回一个布尔值，表示参数是否为数组。

- 它可以弥补 `typeof` 运算符的不足。`typeof` 运算符只能显示数组的类型是 `Object`，而 `Array.isArray` 方法可以识别数组。

```js
var arr = [1, 2, 3]

typeof arr // "object"
Array.isArray(arr) // true
```

### (3) 实例方法

1. `valueOf()`，`toString()`

- `valueOf` 方法是一个所有对象都拥有的方法，表示对该对象求值。数组的 `valueOf` 方法返回数组本身。

```js
var arr = [1, 2, 3]
arr.valueOf() // [1, 2, 3]
```

- `toString` 方法也是对象的通用方法，数组的 `toString` 方法返回数组的字符串形式。

```js
var arr = [1, 2, 3]
arr.toString() // "1,2,3"

var arr = [1, 2, 3, [4, 5, 6]]
arr.toString() // "1,2,3,4,5,6"
```

2. `push()`，`pop()`

- `push` 方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。该方法会改变原数组。

```js
var arr = []

arr.push(1) // 1
arr.push(true, {}) // 3
arr // [1, true, {}]
```

- `pop` 方法用于删除数组的最后一个元素，并返回该元素，该方法会改变原数组。

```js
var arr = ['a', 'b', 'c']

arr.pop() // 'c'
arr // ['a', 'b']
```

3. `unshift()`，`shift()`

- `unshift`，方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度，该方法会改变原数组。

```js
var a = ['a']

a.unshift('x') // 2
a // ['x', 'a']

a.unshift('s', 'b') // 4
a // ['s', 'b', 'x', 'a']
```

- `shift`，方法用于删除数组的第一个元素，并返回该元素，该方法会改变原数组。

```js
var a = ['a', 'b', 'c']

a.shift() // 'a'
a // ['b', 'c']
```

4. `join()`，方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。

```js
var a = [1, 2, 3, 4]
a.join(' ') // '1 2 3 4'
a.join(' | ') // "1 | 2 | 3 | 4"
a.join() // "1,2,3,4"
```

- 如果数组成员是 `undefined` 或 `null` 或空位，会被转成空字符串。

```js
[undefined, null].join('#') // '#'

['a',, 'b'].join('-') // 'a--b'
```

- 通过 `call` 方法，这个方法也可以用于字符串或类似数组的对象。

```js
Array.prototype.join.call('hello', '-') // "h-e-l-l-o"

var obj = { 0: 'a', 1: 'b', length: 2 }
Array.prototype.join.call(obj, '-') // 'a-b'
```

5. `concat()`，方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。

```js
var arr = ['hello']

arr.concat(['world']) // ["hello", "world"]

arr.concat(['world'], ['!']) // ["hello", "world", "!"]

arr.concat({ a: 1 }, { b: 2 }) // ['hello',{ a: 1 }, { b: 2 }]

arr.concat(4, 5, 6) // ['hello', 4, 5, 6]

arr // ['hello']
```

## 4. 包装对象

## 5. Boolean 对象

## 6. Number 对象

## 7. String 对象

## 8. Math 对象

## 9. Date 对象

## 10. RegExp 对象

## 11. JSON 对象
