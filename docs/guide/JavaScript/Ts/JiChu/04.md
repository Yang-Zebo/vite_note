# Class-类

`TypeScript`完全支持`ES2015`中引入的`class`关键字，`TypeScript`添加了类型注释和其他语法，以允许你表达类和其他类型之间的关系。

## 1. 类成员

1. 类型注释是可选的，可以写在属性声明后面，但如果未指定，则为隐式`any`。
   ```typescript
   // 创建公共可写属性
   class Point {
     x: number
     y: number
   }
   const pt = new Point()
   pt.x = 0
   pt.y = '0' // error
   ```
2. 可以在`tsconfig.json`配置`strictPropertyInitialization`
   ，启用此选项时编译器会要求类的属性在构造函数中被明确初始化。或者显示地声明属性为`undefined`类型或者使用非空断言。
   ```typescript
   // 开启 strictPropertyInitialization 之后, 构造函数中初始化，或者其他写法
   class Point1 {
     name: string
     constructor(name: string = '') { // 在构造函数中始终提供一个默认值
       this.name = name
     }
   }
   
   class Point2 {
     name: string | undefined // 显式允许 undefined
     constructor(name?: string) {
       this.name = name
     }
   }
   
   class Point3 {
     name!: string // 使用非空断言操作符，它会绕过类型检查
     constructor(name?: string) {
       this.name = name
     }
   }
   ```
3. 字段可以以`readonly`修饰符作为前缀，这可以防止对构造函数之外的字段进行赋值。
   ```typescript
   class Greeter {
     readonly name: string = 'world'
     constructor(otherName?: string) {
       if (otherName !== undefined) {
         this.name = otherName // ok
       }
     }
     err() {
       this.name = 'not ok' // error，只读属性只能在构造函数中赋值
     }
   }
   const g = new Greeter()
   g.name = 'also not ok' // error，只读属性只能在构造函数中赋值
   ```
4. 类构造函数的类型注释与函数非常相似，可以添加带有类型注释、默认值和重载的参数。
   - 构造函数不能有类型参数。
   - 构造函数不能有返回类型。
   ```typescript
   class Point {
     x: number
     y: number
     constructor(x = 0, y = 0) {
       this.x = x
       this.y = y
     }
   }
   class Point {
     x: number = 0
     y: number = 0
     constructor(x: number, y: number)
     constructor(x: string)
     constructor(x: string | number, y: number = 0) {
     }
   }
   ```