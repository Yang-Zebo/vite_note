# 标准库
## 1. Object 对象
### (1) 概述
1. `JavaScript` 原生提供 `Object` 对象，`JavaScript` 的所有其他对象都继承自 `Object` 对象，即那些对象都是 `Object` 的实例。
2. `Object` 对象的原生方法分成两类：`Object` 本身的方法（静态方法）与 `Object` 的实例方法。
- `Object` 对象本身的方法就是直接定义在 `Object` 对象的方法。
```js
Object.print = function () {  }
```
- `Object` 的实例方法就是定义在 `Object` 原型对象 `Object.prototype` 上的方法。它可以被 `Object` 实例直接使用。
```js
Object.prototype.print = function () {
  return 'print'
}
var obj = new Object();
obj.print() // print
```
### (2) Object() 函数
1. `Object` 本身是一个函数，可以当作工具方法使用，将任意值转为对象。这个方法常用于保证某个值一定是对象。
2. 如果参数为空或者为 `undefined` 和 `null`，`Object()`返回一个空对象。
```js
var obj = Object();
// 等同于
var obj = Object(undefined);
var obj = Object(null);

obj instanceof Object // true
```
3. 如果参数是原始类型的值，`Object` 方法将其转为对应的包装对象的实例。
```js
var obj = Object(1);
obj instanceof Object // true
obj instanceof Number // true

var obj = Object('foo');
obj instanceof Object // true
obj instanceof String // true

var obj = Object(true);
obj instanceof Object // true
obj instanceof Boolean // true
```
4. 如果 `Object` 方法的参数是一个对象，它总是返回该对象，即不用转换。
```js
var arr = [];
var obj = Object(arr); // 返回原数组
obj === arr // true

var value = {};
var obj = Object(value) // 返回原对象
obj === value // true

var fn = function () {};
var obj = Object(fn); // 返回原函数
obj === fn // true
```
5. 利用这一点，可以写一个判断变量是否为复杂数据类型的函数。
```js
function isObject(value) {
  return value === Object(value);
}

isObject([]) // true
isObject(true) // false
```
### (3) Object 构造函数
1. `Object` 还可以当作构造函数使用，构造函数的首要用途，是直接通过它来生成新对象。
```js
var obj = new Object();
// 与字面量的写法 var obj = {} 是等价的
```
2. `Object` 构造函数的用法与工具方法很相似，可以接受一个参数。
- 如果该参数是一个对象，则直接返回这个对象。
- 如果该参数是一个原始类型的值，则返回该值对应的包装对象。
```js
var o1 = {a: 1};
var o2 = new Object(o1);
o1 === o2 // true

var obj = new Object(123);
obj instanceof Number // true
```
3. `Object(value)` 与 `new Object(value)` 两者的语义是不同的，前者表示将`value`转成一个对象，
后者则表示新生成一个对象，它的值是 `value`。
### (4) Object 静态方法（自身方法）
1. `Object.keys`
- 方法的参数是一个对象，返回一个数组。该数组的成员都是该对象自身的而不是继承的所有属性名。
- 方法只返回可枚举的属性。
```js
var obj = {
  p1: 123,
  p2: 456
};

Object.keys(obj) // ["p1", "p2"]
```
2. `Object.getOwnPropertyNames`
- 方法是接受一个对象作为参数，返回一个数组，包含了该对象自身的所有属性名。
- 方法还可以返回不可枚举的属性名。数组的 `length` 属性是不可枚举的属性。
```js
var a = ['Hello', 'World'];
Object.getOwnPropertyNames(a) // ["0", "1", "length"] 
```
3. 其他静态方法
- 对象属性模型的相关方法
  - `Object.getOwnPropertyDescriptor()`：获取某个属性的描述对象。
  - `Object.defineProperty()`：通过描述对象，定义某个属性。
  - `Object.defineProperties()`：通过描述对象，定义多个属性。
- 控制对象状态的方法
  - `Object.preventExtensions()`：防止对象扩展。
  - `Object.isExtensible()`：判断对象是否可扩展。
  - `Object.seal()`：禁止对象配置。
  - `Object.isSealed()`：判断一个对象是否可配置。
  - `Object.freeze()`：冻结一个对象。
  - `Object.isFrozen()`：判断一个对象是否被冻结。
- 原型链相关方法
  - `Object.create()`：该方法可以指定原型对象和属性，返回一个新的对象。
  - `Object.getPrototypeOf()`：获取对象的 `Prototype` 对象。
### (5) Object 实例方法（ 在 Object.prototype 上的方法）
1. `Object.prototype.valueOf()`
- 返回当前对象对应的值，默认情况下返回对象本身。
```js
var obj = new Object()
obj.valueOf() === obj // true
```
- `JavaScript` 自动类型转换时会默认调用 `valueOf()` 方法。
```js
// 自定义的 obj.valueOf，覆盖 Object.prototype.valueOf
var obj = new Object();
obj.valueOf = function () {
  return 2;
};

1 + obj // 3
```
2. `Object.prototype.toString()`
- 返回一个对象的字符串形式，默认情况下返回类型字符串。可以看出一个值到底是什么类型。
```js
var o2 = {a:1};
o2.toString() // "[object Object]"
Object.prototype.toString.call(2) // "[object Number]"
```
- 对象在自动类型转换时会调用 `toString()` 方法。
```js
var obj = new Object();

obj.toString = function () {
  return 'hello';
};

obj + ' world' // "hello world"
```
3. `Object.prototype.toLocaleString()`
- 方法与 `toString` 的返回结果相同，也是返回一个值的字符串形式。
- 方法主要作用是留出一个接口，让不同的对象实现自己版本的 `toLocaleString`，用来返回针对某些地域的特定的值。
```js
var person = {
  toString: function () {
    return 'toString';
  },
  toLocaleString: function () {
    return 'toLocaleString';
  }
}

person.toString() // toString
person.toLocaleString() // toLocaleString
```
- 主要有三个对象自定义了 `toLocaleString` 方法。
  - `Array.prototype.toLocaleString()`
  - `Number.prototype.toLocaleString()`
  - `Date.prototype.toLocaleString()`
```js
var date = new Date();
date.toString() // "Tue Jan 01 2018 12:01:33 GMT+0800 (CST)"
date.toLocaleString() // "1/01/2018, 12:01:33 PM"
```
4. `Object.prototype.hasOwnProperty()`，方法接受一个字符串作为参数，返回一个布尔值，表示该实例对象自身是否具有该属性。
继承的属性不能找到。
```js
var obj = {
  p: 123
};

obj.hasOwnProperty('p') // true
obj.hasOwnProperty('toString') // false
```
## 2. 对象的属性描述对象
### (1) 概述
1. `JavaScript` 提供了一个内部数据结构，用来描述对象的属性，控制它的行为。这个内部数据结构称为“属性描述对象。
2. 每个属性都有自己对应的属性描述对象，保存该属性的一些元信息。属性描述对象提供 6 个元属性。
```js
{
  value: 'JavaScript',
  // value是该属性的属性值，默认为undefined。
  writable: false,
  // writable是一个布尔值，表示属性值（value）是否可改变（即是否可写），默认为true。
  enumerable: true,
  // enumerable是一个布尔值，表示该属性是否可遍历，默认为true。
  configurable: false,
  // configurable是一个布尔值，表示属性的可配置性，默认为true。
  // 如果设为false，将无法删除该属性，也不得改变除 value 属性外的元属性。
  get: undefined,
  // get是一个函数，表示该属性的取值函数，默认为undefined。
  set: undefined   
  // set是一个函数，表示该属性的存值函数，默认为undefined。
}
``` 
### (2) Object.getOwnPropertyDescriptor()
1. 方法可以获取属性描述对象。它的第一个参数是目标对象，第二个参数是一个字符串，对应目标对象的某个属性名。
```js
var obj = { p: 'a' };

Object.getOwnPropertyDescriptor(obj, 'p')
// { 
//   value: "a",
//   writable: true,
//   enumerable: true,
//   configurable: true
// }
```
2. 方法只能用于对象自身的属性，不能用于继承的属性。
```js
var obj = { p: 'a' };

Object.getOwnPropertyDescriptor(obj, 'toString')
// undefined
```
### (3) Object.defineProperty()
1. 方法允许通过属性描述对象，定义或修改一个属性，然后返回修改后的对象。
2. 方法接受三个参数：
- 属性所在的对象
- 字符串，表示属性名
- 属性描述对象
```js
var obj1 = { p: 111 } 
var obj2 = Object.defineProperty({}, 'p', {
  value: 123,
  writable: false,
  enumerable: true,
  configurable: false
});
obj1.p // 123
obj1 === obj2 // true
```
3. 如果写入的对象或对象的属性已经存在，方法相当于更新该属性的属性描述对象。
4. 定义了取值函数`get`或存值函数`set`，就不能将`writable`属性设为`true`，或者同时定义`value`属性，否则会报错。
### (4) Object.defineProperties()
1. 方法功能与上个一样，但是能一次性定义或修改多个属性。
```js
var obj = Object.defineProperties({}, {
  p1: { value: 123, enumerable: true },
  p2: { value: 'abc', enumerable: true },
  p3: { get: function () { return this.p1 + this.p2 },
    enumerable:true,
    configurable:true
  }
});
```
2. 定义了取值函数`get`或存值函数`set`，就不能将`writable`属性设为`true`，或者同时定义`value`属性，否则会报错。
### (5) Object.prototype.propertyIsEnumerable()
1. 方法返回一个布尔值，用来判断某个属性是否可遍历。
2. 方法只能用于判断对象自身的属性，对于继承的属性一律返回`false`。
```js
var obj = {};
obj.p = 123;

obj.propertyIsEnumerable('p') // true
obj.propertyIsEnumerable('toString') // false
```
### (6) 存取器
1. 属性还可以用存取器定义，一旦对目标属性定义了存取器，那么存取的时候，都将执行对应的函数。
2. 存值函数称为`setter`，使用属性描述对象的`set`属性。取值函数称为`getter`，使用属性描述对象的`get`属性。
- 第一种写法，`obj.p`定义了`get`和`set`属性。
  - `obj.p`取值时，就会调用`get`；赋值时，就会调用`set`。
  - 这种写法，属性`p`的`configurable`和`enumerable`都为`false`，从而导致属性`p`是不可遍历的。
```js
var obj = {}
Object.defineProperty(obj, 'p', {
  get: function () {
    return 'getter';
  },
  set: function (value) {
    console.log('setter: ' + value);
  }
});
obj.p // "getter"
obj.p = 123 // "setter: 123"
```
- 第二种写法，属性`p`的读取和赋值行为与第一种一样。
  - `obj.p`取值时，就会调用`get`；赋值时，就会调用`set`。
  - 这种写法属性`p`的`configurable`和`enumerable`都为`true`，因此属性`p`是可遍历的。
```js
var obj = {
  get p() {
    return 'getter';
  },
  set p(value) {
    console.log('setter: ' + value);
  }
}
```
3. 取值函数`get`不能接受参数，存值函数`set`只能接受一个参数（即属性的值）。
### (7) 控制对象状态
1. 有时需要冻结对象的读写状态，防止对象被改变，`JavaScript` 提供了三种冻结方法。
- 最弱的一种是 `Object.preventExtensions`。
- 其次是 `Object.seal`。
- 最强的是 `Object.freeze`。
2. 控制添加新属性
- `Object.preventExtensions()`，方法可以使得一个对象无法再添加新的属性。
```js
var obj = {}

obj.p = 1;
obj.p // undefined

Object.defineProperty(obj, 'p', {
  value: 'hello'
});
// TypeError: Cannot define property:p, object is not extensible.
```
- `Object.isExtensible()`，方法用于检查一个对象是否使用了`Object.preventExtensions`方法。
也就是检查是否可以为一个对象添加属性。
```js
var obj = {}

Object.isExtensible(obj) // true
Object.preventExtensions(obj);
Object.isExtensible(obj) // false
```
3. 控制添加和删除新属性
- `Object.seal()`，方法使得一个对象既无法添加新属性，也无法删除旧属性。
```js
var obj = { p: 'hello' };
Object.seal(obj);

delete obj.p;
obj.p // "hello"

obj.x = 'world';
obj.x // undefined
```
- `Object.seal`实质是把属性描述对象的`configurable`属性设为`false`，因此属性描述对象也不再能改变了。
```js
var obj = {
  p: 'a'
}

// seal方法之前
Object.getOwnPropertyDescriptor(obj, 'p')
// Object {
//   value: "a",
//   writable: true,
//   enumerable: true,
//   configurable: true
// }

// seal方法之后
Object.getOwnPropertyDescriptor(obj, 'p')
// Object {
//   value: "a",
//   writable: true,
//   enumerable: true,
//   configurable: false
// }

// 使用Object.seal方法之后，属性描述对象的configurable属性就变成了false，
// 然后改变enumerable属性就会报错。
Object.defineProperty(obj, 'p', {
  enumerable: false
})
// TypeError: Cannot redefine property: p
```
## 3. Array 对象
## 4. 包装对象
## 5. Boolean 对象
## 6. Number 对象
## 7. String 对象
## 8. Math 对象
## 9. Date 对象
## 10. RegExp 对象
## 11. JSON 对象