# 浏览器器与网络相关

## 1. 浏览器搜索过程

### URL 解析/DNS 查询

1. `URL`，统一资源定位系统`(uniform resource locator)`是因特网的万维网服务程序上用于指定信息位置的表示方法。
2. 完整的`URL`由几个部分构成：协议、网络地址、资源路径、文件名、动态参数。

- 协议：是从该计算机获取资源的方式。例如：`Http`、`Https`、`File` 等协议，不同协议有不同的通讯内容格式，协议主要作用是告诉浏览器如何处理将要打开的文件。
- 网络地址：指示该连接网络上哪一台计算机（服务器），可以是域名或者`IP`地址，域名或 IP 地址后面有时还跟一个冒号和一个端口号。端口号如果地址不包含端口号，根据协议的类型会确定一个默认端口号。
- 资源路径：指示从服务器上获取哪一项资源的路径，以斜线`/`分隔。
- 文件名一般是需要真正访问的文件，有时候，`URL` 以斜杠`/`结尾，而隐藏了文件名，在这种情况下，`URL` 引用路径中最后一个目录中的默认文件，这个文件常被称为 `index.html`。
- 动态参数：有时候路径后面会有以问号`?`开始的参数，这一般都是用来传送对服务器上的数据库进行动态询问时所需要的参数。

3. 浏览器对 `URL` 进行检查时首先判断协议，如果是 `http/https` 就按照 `Web` 来处理，然后直接调用浏览器内核中的对应方法对 `URL` 进行安全检查。
4. 接下来是对网络地址进行处理，如果地址不是一个 `IP` 地址而是域名则通过 `DNS`（域名系统）将该地址解析成 `IP` 地址。`DNS` 在解析域名的时候有两种方式：递归查询和迭代查询。

- 递归查询：浏览器会首先查询浏览器缓存 - 如果没有找到就会检查系统缓存，检查本地硬盘的`hosts`文件 - 如果本地 `hosts` 也没有找到的话，则需要再向上层找路由器缓存，路由器有自己的 `DNS` 缓存，可能就包括了查询的内容 - 如果还是没有，需要接着往上找，查询 `ISP DNS` 缓存，会先从附近本地`DNS`服务器开始找 - 权威名称服务器 - 顶级名称服务器 - 根名称服务器。

![alt text](./images/digui.png 'DNS 递归解析')

- 迭代查询：开始也是从浏览器缓存到系统缓存到路由缓存，如果还是没找到则客户端向本机配置的本地名称服务器，如果本地缓存中没有该域名的记录，则向 `DNS` 客户端返回一条 `DNS` 应答报文，报文中会给出一些参考信息。`DNS` 客户端在收到本地名称服务器的应答报文后，会根据其中的根名称服务器地址信息，向对应的根名称服务器再次发出与前面一样的 `DNS` 查询请求报文。如此循环一直查到权威名称服务器。

![alt text](./images/diedai.png 'DNS 迭代解析')

### 浏览器构造 HTTP 请求

1. 从上面的步骤中得到 `IP` 地址后，浏览器会开始构造一个 `HTTP` 请求。
2. 应用层客户端向服务器端发送的 `HTTP` 请求包括：

- 请求行：描述请求的基本信息。包括：
  - 请求方法：是一个动词，如 `GET/POST`，表示对资源的操作；
  - 请求目标：通常是一个 `URI`，标记了请求方法要操作的资源；
  - 版本号：表示报文使用的 `HTTP` 协议版本。
- 头部字段集合：使用 `key-value` 形式更详细地说明报文；
- 空行：`CRLF`；
- 消息正文：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据；

3. 请求行加上头部字段集，被称为请求头。消息正文被称为请求体。

### 应用层客户端发送 HTTP 请求

1. 互联网内各网络设备间的通信都遵循 `TCP/IP` 协议，利用 `TCP/IP` 协议族进行网络通信时，会通过分层顺序与对方进行通信。
2. 分层由高到低分别为：应用层、传输层、网络层、数据链路层。
3. 发送端从应用层往下走，接收端从数据链路层网上走。
   ![alt text](./images/fasong.png '应用层客户端发送HTTP请求')

### 传输层 TCP 传输报文

1. 当应用层的 `HTTP` 请求准备好后，浏览器会在传输层发起一条到达服务器的 `TCP` 连接，位于传输层的 `TCP` 协议为传输报文提供可靠的字节流服务。
2. 它为了方便传输，将大块的数据分割成以报文段为单位的数据包进行管理，并为它们编号，方便服务器接收时能准确地还原报文信息，这就是所谓的三次握手。

### 网络层 IP 协议查询 MAC 地址

1. `IP` 协议的作用是把 `TCP` 分割好的各种数据包封装到 `IP` 包里面传送给接收方。
2. 而要保证确实能传到接收方还需要接收方的 `MAC` 地址，也就是物理地址才可以。`IP` 地址和 `MAC` 地址是一一对应的关系，一个网络设备的 `IP` 地址可以更换，但是 `MAC` 地址一般是固定不变的。
3. `ARP` 协议可以将 `IP` 地址解析成对应的 `MAC` 地址。当通信的双方不在同一个局域网时，需要多次中转才能到达最终的目标，在中转的过程中需要通过下一个中转站的 `MAC` 地址来搜索下一个中转目标。

### 数据到达数据链路层

1. 在找到对方的 `MAC` 地址后，已被封装好的 `IP` 包再被封装到数据链路层的数据帧结构中，将数据发送到数据链路层传输。
2. 再通过物理层的比特流送出去，这时，客户端发送请求的阶段结束。

### 服务器接收数据

1. 接收端的服务器在链路层接收到数据包，再层层向上直到应用层。
2. 这过程中包括在传输层通过 `TCP` 协议将分段的数据包重新组成原来的 `HTTP` 请求报文。

### 服务器响应请求并返回相应文件

1. 服务接收到客户端发送的 `HTTP` 请求后，服务器上的的 `http` 监听进程会得到这个请求，然后一般情况下会启动一个新的子进程去处理这个请求，同时父进程继续监听。
2. 请求进入处理函数之后，如果请求的文件是真实存在，例如一些图片，或 `html`、`css`、`js` 等静态文件，会直接把这个文件返回。如果请求需要浏览的内容是一个动态的内容，那么处理函数会相应的从数据源里面取出数据。由 `http` 服务器把这些正文加上一个响应头，封装成一个标准的 `http` 响应包，再通过 `tcp` `ip` 协议，送回到客户机浏览器。

### 浏览器开始处理数据信息并渲染页面

1. 浏览器根据返回的响应报文里的状态码来做个判断，进行对数据的不同处理。
2. 响应报文格式：

- 状态行，描述响应的基本信息，组成部分
  - 版本号：表示报文使用的 `HTTP` 协议版本；
  - 状态码：一个三位数，用代码的形式表示处理的结果，比如 `200` 是成功，`500` 是服务器错误；
  - 原因：作为数字状态码补充，是更详细的解释文字，帮助人理解原因。
- 头部字段集合：使用 `key-value` 形式更详细地说明报文；
- 空行
- 消息正文：响应的数据，它不一定是纯文本，可以是图片、视频等二进制数据。

3. 状态行加上头部字段集，被称为响应头。消息正文被称为响应体。
## 2. http 发展历程
1. HTTP 发展至今，总共经历了四个版本——HTTP 0.9、HTTP 1.0、HTTP 1.1、HTTP 2.0 。
### http 0.9
1. HTTP 0.9 是最早发布出来的一个版本，于1991年发布。
2. http 0.9 特点：
   - 它只接受 GET 一种请求方法。
   - 没有在通讯中指定版本号，且不支持请求头。
   - 传输的数据为纯文本格式。
   - HTTP 0.9 具有典型的无状态性，每个事务独立进行处理，事务结束时就释放这个连接。
### http 1.0
1. HTTP 1.0是HTTP协议的第二个版本，于1996年发布，如今仍然被广泛使用，尤其是在代理服务器中。
2. 这是第一个在通讯中指定版本号的HTTP协议版本，具有以下特点：
   - 不仅仅支持 GET 命令，还支持 POST 和 HEAD 等请求方法。
   - HTTP 的请求和回应格式也发生了变化，除了要传输的数据之外，每次通信都包含头信息，用来描述一些信息。
   - 不再局限于 0.9 版本的纯文本格式，根据头信息中的 Content-Type 属性，可以支持多种数据格式。
   - 开始支持cache，就是当客户端在规定时间内访问同一网站，直接访问cache即可。
   - 其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、
     缓存（cache）、内容编码（content encoding）等。
3. 解决keep-alive问题：
   - 原因：HTTP 1.0 版本的工作方式是每次 TCP 连接只能发送一个请求，当服务器响应后就会关闭这次连接，下一个请求需要再次建立 TCP 
     连接。 TCP 连接的建立成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢。随着网页加载的外部资源越来越多，这个问题就愈发突出了。
   - 为了解决这个问题，有些浏览器在请求时，即在请求头部加上 `Connection：keep-alive` 要求服务器不要关闭TCP连接，以便其他请求复用。
     服务器同样回应这个字段。一个可以复用的TCP连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是一个标准字段，
     不同实现的行为可能不一致，因此不是根本的解决办法。
### http 1.1
1. HTTP 1.1 具有以下特点：
   - 引入持久连接，即 TCP 连接默认不关闭，可以被多个请求复用，不用声明 Connection: keep-alive。客户端在最后一个请求时，发送 Connection: close，明确要求服务器关闭 TCP 连接。
   - 加入了管道机制，在同一个 TCP 连接里，允许多个请求同时发送，增加了并发性，进一步改善了 HTTP 协议的效率。但是服务器还是按照请求的顺序完成响应。
     一个 TCP 连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是 Content-length 字段的作用，声明本次回应的数据长度。
   - 分块传输编码 HTTP 1.1 版本规定可以不使用 Content-Length 字段，而使用"分块传输编码"（chunked transfer encoding）。只要请求或回应的头信息有 
     Transfer-Encoding 字段，就表明回应将由数量未定的数据块组成。
   - 新增了请求方式 PUT、PATCH、OPTIONS、DELETE 等。
   - 客户端请求的头信息新增了 Host 字段，用来指定服务器的域名。
   - HTTP 1.1 支持文件断点续传，RANGE:bytes，HTTP 1.0 每次传送文件都是从文件头开始，即 0 字节处开始。`RANGE:bytes=XXXX` 
     表示要求服务器从文件 `XXXX` 字节处开始传送，断点续传。即返回码是 206（Partial Content）
### http 2.0
1. HTTP/2.0是最新的 HTTP 版本，于 2015 年 5 月作为互联网标准正式发布。 它具有以下特点： 
   - 二进制分帧，HTTP 1.1 版的头信息肯定是文本（ASCII 编码），数据体可以是文本，也可以是二进制。
     HTTP 2.0 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"（frame）：头信息帧和数据帧。
   - 多路服用，HTTP 2.0 复用 TCP 连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应。
   - 头信息压缩，HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，HTTP 2.0 对这一点做了优化，
     引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，
     所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。
   - 服务器推送，HTTP 2.0 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。
### 总结
1. HTTP/0.9：功能捡漏，只支持GET方法，只能发送HTML格式字符串，没有请求头信息。
2. HTTP/1.0：支持多种数据格式，增加POST、HEAD等方法，增加头信息，每次只能发送一个请求（无持久连接）
3. HTTP/1.1：默认持久连接、请求管道化、增加缓存处理、增加Host字段、支持断点传输分块传输等。
4. HTTP/2.0：二进制分帧、多路复用、头部压缩、服务器推送
## 3. 三次握手

1. TCP 协议通过“三次握手”等方法保证传输的安全可靠。
2. “三次握手”的过程是：

- 发送端先发送一个带有 `SYN(synchronize)` 标志的数据包给接收端，在一定的延迟时间内等待接收的回复。
- 接收端收到数据包后，传回一个带有 `SYN/ACK` 标志的数据包以示传达确认信息。
- 接收方收到后再发送一个带有 `ACK` 标志的数据包给接收端以示握手成功。
- 在这个过程中，如果发送端在规定延迟时间内没有收到回复则默认接收方没有收到请求，而再次发送，直到收到回复为止。
  ![alt text](./images/woshou.png '三次握手')
## 4. 四次挥手
1. TCP 协议通过“四次挥手”保证数据传输的完整性。
2. "四次挥手"的过程是：
   - 客户端主动调用关闭连接的函数，于是就会发送 FIN 报文，这个 FIN 报文代表客户端不会再发送数据了，进入 FIN_WAIT_1 状态；
   - 服务端收到了 FIN 报文，然后马上回复一个 ACK 确认报文，此时服务端进入 CLOSE_WAIT 状态。
   这时服务端应用程序如果有数据要发送的话，就发完数据后才调用关闭连接的函数。调用关闭连接的函数，这时服务端就会发一个 FIN 包，
   这个 FIN 报文代表服务端不会再发送数据了，之后处于 LAST_ACK 状态；
   - 客户端接收到服务端的 FIN 包，并发送 ACK 确认包给服务端，此时客户端将进入 TIME_WAIT 状态；
   - 服务端收到 ACK 确认包后，就进入了最后的 CLOSE 状态；客户端经过 2MSL 时间之后，也进入 CLOSE 状态；
   - 规定是MSL为2分钟，2MSL就是4分钟。但是实际中30秒、1分钟、2分钟都在使用
   ![alt text](./images/huishou.png '四次挥手')
## 5. 解决跨域
### jsonp （json with padding）
1. 使用 script 标签，引入 JS 文件不会发生跨域，但是 script 标签发送的是 get 请求
### CORS (CROSS-Origin Resource Sharing 跨域资源共享)
1. 简单请求与非简单请求：
   - 请求方法是以下三种方法之一： HEAD，GET，POST
   - HTTP的头信息不超出以下几种字段：Accept，Accept-Language，Content-Language，Last-Event-ID，Content-Type
   - Content-Type：只限于三个值 `application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`
   - 除了以上情况就是非简单请求
2. 后端响应头配置信息
   - Access-Control-Allow-Origin，该字段是必须的。它的值要么是请求时 Origin 字段的值，要么是一个"*"，
     表示接受任意域名的请求。请求头信息中，请求头的 Origin 字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。
     服务器根据这个值，决定是否同意这次请求。
   - Access-Control-Allow-Credentials 该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。
     默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。
   - Access-Control-Expose-Headers：CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：
     Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。
     如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。
3. 默认情况下，只有简单请求能够跨域，如果是非简单请求就我们在发送请求的时候更要在请求头中穿信息来告诉服务器
   - 除了Origin字段，"预检"请求的头信息包括两个特殊字段。Access-Control-Request-Method
    该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法。
   - Access-Control-Request-Headers 该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，
4. 需要在后端响应头上再进行配置。
   - Access-Control-Allow-Methods，该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的所有方法。
   - Access-Control-Allow-Headers，如果客户端发送的请求头 Access-Control-Request-Headers字段，则此字段是必需的。
     它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段。
   - Access-Control-Allow-Credentials，与简单请求的效果一样
   - Access-Control-Max-Age，该字段可选，用来指定本次预检请求的有效期，单位为秒。在此期间，不用发出另一条预检请求。
### 代理（proxy）
1. 代理分成正向代理与反向代理。
   - 正向代理配置
```js
module.exports = {
  devServer: {
    proxy: { 
      '/api1': {
        // 匹配所有以 '/api1'开头的请求路径 
        target: 'http://localhost:5000',// 代理目标的基础路径 
        changeOrigin: true,
        pathRewrite: {'^/api1': ''}
      },
      '/api2': {
        // 匹配所有以 '/api2'开头的请求路径 
        target: 'http://localhost:5001',// 代理目标的基础路径 
        changeOrigin: true,
        pathRewrite: {'^/api2': ''}
      }
    }
  }
}
```

## 6. 浏览器缓存策略
### 缓存过程分析
1. 浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中 HTTP 头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中。
2. 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识。浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中
   ![alt text](./images/huancun1.png '缓存解析')
   
### 强制缓存
1. 强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，强制缓存的情况主要有三种，如下：
    - 不存在该缓存结果和缓存标识，则直接向服务器发起请求（跟第一次发起请求一致）
      ![alt text](./images/huancun2.png '强制缓存失败')
    - 存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存。
      ![alt text](./images/huancun3.png '强制缓存失败使用协商缓存')
    - 存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果
      ![alt text](./images/huancun4.png '强制缓存成功')
2. 当浏览器向服务器发起请求时，服务器会将缓存规则放入 HTTP 响应报文的响应头中和请求结果一起返回给浏览器，
   控制强制缓存的字段分别是 Expires 和 Cache-Control，其中 Cache-Control 优先级比 Expires 高。
3. 强制缓存返回的状态值是200，size下会显示字段。
   - from memory cache 代表使用内存中的缓存。
   - from disk cache 则代表使用的是硬盘中的缓存。
   - 浏览器读取缓存的顺序为 memory –> disk。
### Expires 
1. Expires 是 HTTP/1.0 控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。
2. Expires 控制缓存的原理是使用客户端的时间与服务端返回的时间做对比（使用绝对时间），时间因为某些原因发生误差，那么强制缓存则会直接失效。
### Cache-Control
1. 到了HTTP/1.1，Expire 已经被 Cache-Control 替代。主要取值为：
   - public：所有内容都可被缓存
   - private：所有内容只有客户端可以缓存，Cache-Control的默认取值
   - no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定
   - no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存
   - max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效（相对时间）
2. 除了值为 no-cache，都是强制缓存，否则就是都是先看是否满足强制缓存才看协商缓存。
### 协商缓存
1. 协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：
   - 协商缓存生效，返回状态码 304 ，如下
     ![alt text](./images/huancun5.png '协商缓存成功')
   - 协商缓存失效，返回状态码 200 和请求结果结果
     ![alt text](./images/huancun6.png '协商缓存成功')
2. 协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：
   - `Last-Modified` / `If-Modified-Since`
   - `Etag` / `If-None-Match`
   - 其中 `Etag / If-None-Match` 的优先级比 `Last-Modified / If-Modified-Since` 高。
     同时存在则只有 `Etag / If-None-Match` 生效。
### Last-Modified / If-Modified-Since
1. Last-Modified 是服务器响应请求时，返回该资源文件在服务器最后被修改的时间。
2. If-Modified-Since 则是客户端再次发起该请求时，携带上次请求返回的 Last-Modified 值。
3. 服务器收到该请求，发现请求头含有 If-Modified-Since 字段，则会根据 If-Modified-Since 的字段值与该资源在服务器的最后被修改时间做对比，
   若服务器的资源最后被修改时间大于 If-Modified-Since 的字段值，则重新返回资源，状态码为 200；否则则返回 304，代表资源无更新，可继续使用缓存文件。
### Etag / If-None-Match
1. Etag 是服务器响应请求时，返回当前资源文件的一个唯一标识。
2. If-None-Match 是客户端再次发起该请求时，携带上次请求返回的唯一标识 Etag 值。
3. 服务器收到该请求后，发现该请求头中含有 If-None-Match，则会根据 If-None-Match 的字段值与该资源在服务器的 Etag 值做对比，一致则返回304，
   代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200。
### 总结
1. 强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，返回状态码 200。
2. 若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存。
3. 若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回状态码 304，继续使用缓存。
![alt text](./images/huancun7.png '协商缓存成功')

